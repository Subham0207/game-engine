//
// Created by subha on 17-12-2025.
//
#include <LuaEngine/LuaRegistry.hpp>

#include "EngineState.hpp"
#include "Helpers/Shared.hpp"
#include "LuaEngine/LuaClassBuilder.hpp"
#include "LuaEngine/LuaClassDef .hpp"

template <class T>
LuaClassStub& LuaRegistry::beginClass(const std::string& luaName)
{
    auto key = std::type_index(typeid(T));
    if (m_classes.find(key) != m_classes.end())
        throw std::runtime_error("Class already registered: " + luaName);

    // Factory: no constructor
    auto factory = +[](sol::state& lua, const std::string& name) -> sol::usertype<T> {
        return lua.new_usertype<T>(name, sol::no_constructor);
    };

    auto def = std::make_unique<LuaClassDef<T>>(luaName, factory);
    LuaClassDef<T>* raw = def.get();
    m_classOrder.push_back(key);
    m_classes.emplace(key, std::move(def));
    return LuaClassBuilder<T>(raw);
}

LuaRegistry& LuaRegistry::addGlobal(const std::string& name, const std::string& type, const std::string& doc )
{
    m_globals.push_back({name, type, doc});
    return *this;
}
void LuaRegistry::writeStubs(const std::filesystem::path& outDir) const
{
    auto projectRoot = fs::path(EngineState::state->currentActiveProjectDirectory);
    const fs::path outFile = projectRoot / "EngineAPI" / "engine.lua";

    std::string out;
    out += "-- AUTO-GENERATED FILE. DO NOT EDIT.\n";
    out += "-- Generated by the engine binding registry.\n\n";

    // Classes
    for (const auto& key : m_classOrder)
    {
        const auto& c = m_classes.at(key)->stub();

        out += "---@class " + c.name + "\n";

        for (const auto& f : c.fields)
        {
            if (!f.doc.empty())
                out += "---" + f.doc + "\n";
            out += "---@field " + f.name + " " + f.type + "\n";
        }

        for (const auto& m : c.methods)
        {
            if (!m.doc.empty())
                out += "---" + m.doc + "\n";
            // Using @field methodName fun(...) is LuaLS-friendly.
            out += "---@field " + m.name + " " + m.funType + "\n";
        }

        out += "\n";
    }

    // Globals
    if (!m_globals.empty())
    {
        out += "-- Globals\n";
        for (const auto& g : m_globals)
        {
            if (!g.doc.empty())
                out += "---" + g.doc + "\n";
            out += "---@type " + g.type + "\n";
            out += g.name + " = " + g.name + "\n\n";
        }
    }

    Shared::WriteTextFile(outFile, out);
}

void LuaRegistry::apply(sol::state& lua) const
{
    for (const auto& key : m_classOrder)
    {
        const auto& it = m_classes.find(key);
        it->second->apply(lua);
    }
}
