//
// Created by subha on 17-12-2025.
//
#include <LuaEngine/LuaRegistry.hpp>

#include "EngineState.hpp"
#include "Helpers/Shared.hpp"
#include "LuaEngine/LuaClassDef .hpp"

// ---- no-ctor class
template <typename T>
LuaClassBuilder<T> LuaRegistry::beginClass(const std::string& luaName)
{
    auto key = std::type_index(typeid(T));
    if (m_classes.find(key) != m_classes.end())
        throw std::runtime_error("Class already registered: " + luaName);

    auto factory = [](sol::state& lua, const std::string& name) -> sol::usertype<T> {
        return lua.new_usertype<T>(name, sol::no_constructor);
    };

    auto def = std::make_unique<LuaClassDef<T>>(luaName, factory);
    auto* raw = def.get();
    m_classOrder.push_back(key);
    m_classes.emplace(key, std::move(def));
    return LuaClassBuilder<T>(raw);
}

// ---- ctor class
template <typename T, typename... Ctors>
LuaClassBuilder<T> LuaRegistry::beginClass(const std::string& luaName, sol::constructors<Ctors...>)
{
    auto key = std::type_index(typeid(T));
    if (m_classes.find(key) != m_classes.end())
        throw std::runtime_error("Class already registered: " + luaName);

    auto factory = [](sol::state& lua, const std::string& name) -> sol::usertype<T> {
        return lua.new_usertype<T>(name, sol::constructors<Ctors...>{});
    };

    auto def = std::make_unique<LuaClassDef<T>>(luaName, factory);
    auto* raw = def.get();
    m_classOrder.push_back(key);
    m_classes.emplace(key, std::move(def));
    return LuaClassBuilder<T>(raw);
}

LuaRegistry& LuaRegistry::addGlobal(const std::string& name, const std::string& type, const std::string& doc )
{
    m_globals.push_back({name, type, doc});
    return *this;
}
void LuaRegistry::writeStubs(const std::filesystem::path& outDir) const
{
    auto projectRoot = fs::path(EngineState::state->currentActiveProjectDirectory);
    const fs::path outFile = projectRoot / "EngineAPI" / "engine.lua";

    std::string out;
    out += "-- AUTO-GENERATED FILE. DO NOT EDIT.\n";
    out += "-- Generated by the engine binding registry.\n\n";

    // Classes
    for (const auto& key : m_classOrder)
    {
        const auto& c = m_classes.at(key)->stub();

        out += "---@class " + c.name + "\n";

        for (const auto& f : c.fields)
        {
            if (!f.doc.empty())
                out += "---" + f.doc + "\n";
            out += "---@field " + f.name + " " + f.type + "\n";
        }

        for (const auto& m : c.methods)
        {
            if (!m.doc.empty())
                out += "---" + m.doc + "\n";
            // Using @field methodName fun(...) is LuaLS-friendly.
            out += "---@field " + m.name + " " + m.funType + "\n";
        }

        out += "\n";
    }

    // Globals
    if (!m_globals.empty())
    {
        out += "-- Globals\n";
        for (const auto& g : m_globals)
        {
            if (!g.doc.empty())
                out += "---" + g.doc + "\n";
            out += "---@type " + g.type + "\n";
            out += g.name + " = " + g.name + "\n\n";
        }
    }

    Shared::WriteTextFile(outFile, out);
}

void LuaRegistry::apply(sol::state& lua) const
{
    for (const auto& key : m_classOrder)
    {
        const auto& it = m_classes.find(key);
        it->second->apply(lua);
    }
}

void LuaRegistry::writeLuaRC(const fs::path& projectRoot)
{
    const fs::path luarc = projectRoot / ".luarc.json";

    // Adjust these paths to your project layout
    const std::string json = R"JSON(
{
  "runtime": {
    "version": "Lua 5.4",
    "path": [
      "?.lua",
      "?/init.lua",
      "Assets/Scripts/?.lua",
      "Assets/Scripts/?/init.lua"
    ]
  },
  "workspace": {
    "library": [
      "Assets/Scripts",
      "EngineAPI"
    ],
    "checkThirdParty": false
  },
  "diagnostics": {
    "globals": ["Engine", "Scene", "Input", "Time", "Log"]
  },
  "hint": {
    "enable": true
  }
}
)JSON";

    Shared::WriteTextFile(luarc, json);
}

void LuaRegistry::SetupLua(sol::state& lua, const std::filesystem::path& projectRoot)
{
    LuaRegistry reg;

    Controls::PlayerController::RegisterEngineAPI(reg);

    // Bind into Lua runtime
    reg.apply(lua);

    reg.writeLuaRC(projectRoot);
    reg.writeStubs(projectRoot);
}